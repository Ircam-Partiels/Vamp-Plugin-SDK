<html xmlns:tomboy="http://beatniksoftware.com/tomboy" xmlns:link="http://beatniksoftware.com/tomboy/link" xmlns:size="http://beatniksoftware.com/tomboy/size"><head><META http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Salient points of Vamp document</title><style type="text/css">
        
	body {  }
	h1 { font-size: xx-large;
     	     font-weight: bold;
     	     border-bottom: 1px solid black; }
	div.note { overflow: auto;
		   position: relative;
		   display: block;
		   padding: 5pt;
		   margin: 5pt; 
		   white-space: -moz-pre-wrap; /* Mozilla */
 	      	   white-space: -pre-wrap;     /* Opera 4 - 6 */
 	      	   white-space: -o-pre-wrap;   /* Opera 7 */
 	      	   white-space: pre-wrap;      /* CSS3 */
 	      	   word-wrap: break-word;      /* IE 5.5+ */ }
	</style></head><body><div class="note" id="Salient points of Vamp document" style="width:293;"><a name="#Salient points of Vamp document"></a><h1>Salient points of Vamp document</h1>
<ul><li dir="ltr">Vamp plugin is compiled code delivered in shared library file
</li><li dir="ltr">in C or C++
</li><li dir="ltr">Needs to be recompiled for each platform
</li><li dir="ltr">Requires a host to be of any use
</li><li dir="ltr">advantages over e.g. matlab: applicable to any host, can be faster, doesn't require supporting framework from commercial application
</li><li dir="ltr">Vamp not an acronym
</li><li dir="ltr">Examples: note onset detector, chromagram, amplitude tracker
</li><li dir="ltr">Plugins don't display, just compute
</li><li dir="ltr">Things a plugin always has: - basic descriptive data [ identifier, name, description, maker ] - processing prefs [ input domain, step block size, channels ] - output descriptors
</li><li dir="ltr">may have - parameter descriptors, programs
</li><li dir="ltr">Vamp plugin inherits Vamp::Plugin which inherits Vamp::PluginBase
</li><li dir="ltr">category not specified by the plugin, but through external metadata files (in a trivial text format)
</li><li dir="ltr">Plugin receives non-interleaves audio data as input to process(), returns structured set of feature data representing all features that have been calculated from that audio input
</li><li dir="ltr">Input to process() is quite different depending on whether plugin requests time domain or frequency domain input
</li><li dir="ltr">Plugin can have more than one named output; it calculates features for all of them at once
</li><li dir="ltr">Each call to process() returns zero or more features for each output
</li><li dir="ltr">Each feature has a time, and zero or more values
</li><li dir="ltr">Any "meaning" of the values (ranges, units etc) is defined by the Output Descriptor associated with the output on which the feature is returned -&gt; potential for more semantics to be added via RDF later
</li><li dir="ltr">Time of a feature is either explicit (timestamped in feature) or implicit (based on "time of the process call"), and this depends on the output's sample type</li></ul>





Omissions and future work

<ul><li dir="ltr">Features do not have duration
</li><li dir="ltr">Features can only have a single unit for all bins in the feature.  So feature is an "array of values" rather than a point in a multi-dimensional space (??)</li></ul>


Notes about Vamp itself

<ul><li dir="ltr">It's not a sophisticated invention.  It's just complicated by the fact that in theory the plugin should be able to return *anything*
</li><li dir="ltr">There is a need to compromise between having one arbitrarily complex return structure with no "meaning", and a set of specific return structures with precisely defined meaning but no way to return anything else. -&gt; classic data representation problem
</li><li dir="ltr">A lot about the plugin design is based on existing real-time effects plugin APIs which audio programmers may be familiar with -- rather than on plugins for existing analysis systems or the like
</li><li style="list-style-type: none" dir="ltr"></li></ul></div></body></html>